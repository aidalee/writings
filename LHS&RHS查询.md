**LHS(Left-hand Side)**、**RHS(Right-hand Side)**，是引擎在执行代码的时候，`查询变量的两种方式`**(变量赋值和查询)**。其中的 L、R，分别意味着 Left、Right。这个“左”和“右”，是相对于赋值操作来说的。当变量出现在赋值操作的左侧时，执行的就是 LHS 操作；右侧则执行 RHS 操作。

## LHS

```js
name = 'xl';
```

在这个例子里，`name` 变量出现在赋值操作的左侧，它就属于 LHS。LHS 意味着变量赋值或写入内存，它强调的是一个写入的动作，这种情况下，引擎不关心变量`name`的原始值是什么，只管将值 `1` 赋给 `name` 变量。所以 LHS 查询查的是这个变量对应的内存空间。

## RHS

```js
var myName = name
console.log(name)
```

在这个例子里，第一行有赋值操作，但是 name 在操作的右侧，所以是 RHS；第二行没有赋值操作，引擎对变量`name`的查找目的就是**查询**，这种情况下我们也认为对 name 的查询是 RHS。RHS 意味着变量查找或从内存中读取，它强调的是读这个动作，查询的是变量的内容。

## 为什么要区分LHS引用和RHS引用？

这两种不同的引用方式在对没有声明的变量的处理上是不同的。而这个不同之处对于我们编写代码和分析JS引擎报的错误是很有用处的。

- 当对一个变量执行RHS查询时，如果遍历该变量所在处的词法作用域未能找到这个变量，JS引擎就会抛出 `ReferenceError` 错误如果成功查询到了这个变量，但是对这个变量执行不合理操作，比如对一个非数组的变量执行下标取值，JS引擎就会抛出 `TypeError` 错误。
- 当对一个变量执行LHS查询时，同样在遍历作用域后无法找到该变量，在**非ES5的严格模式**下，系统就会自动在全局作用域中创建一个同名变量，并将引用转移到该新建的全局变量中。而**在ES5的严格模式**下，LHS查询失败时JS引擎会抛出一个同RHS一样的 `ReferenceError` 错误。

因此，对LHS查询和RHS查询的仔细区分和理解无论是对JS执行过程本身的理解还是分析错误都是有所好处的。

