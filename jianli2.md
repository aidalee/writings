<!--
 * @Author: please
 * @Date: 2023-11-16 13:13:38
 * @LastEditors: please
 * @LastEditTime: 2023-12-05 13:52:00
 * @Description: 请填写简介
-->
- 基本信息：
1. 姓名
2. 联系方式 号码/邮箱
3. 个人博客/GitHub
4. 意向 薪资要求

5. 教育背景 学历 专业


- 个人简介
拥有6年前端开发经验，熟练掌握前端工作中所使用到的各项技术栈。如：HTML5、css3、javascript、react、vue、微信小程序开发等。能够使用HTML5加CSS3精确还原设计稿，制作各类动画特效。熟练使用react+antd组件或 vue3+Element实现各类型系统。熟练掌握原生微信小程序和uniapp开发技能。熟练掌握Echarts、antV、v-charts等图表库进行数据可视化开发。

- 技能概述
1. 熟练掌握html、css、javascript，能够精确还原设计稿并实现各种动画交互效果
2. 熟练掌握vue、react、typescript技术栈，具备快速迭代开发移动端H5、pc端管理系统、ERP系统与企业官网等各类系统平台的能力
3. 熟悉微信小程序开发、抖音小程序开发、支付宝生活号开发，并具备多个项目经验
4. 熟悉数据可视化开发，并具有大规模数据可视化渲染经验，熟悉Echarts、antv定制化开发各类图表、地图打点、行驶路线渲染、行驶轨迹回放等
5. 能够独立设计并封装业务组件以供快速开发新需求，并有产出业务组件库soda-ui
6. 能够使用nodejs开发支持团队效率提升的工具和服务,如独立实现GUI工具 lemon-box
7. 具备独立完成项目架构设计与性能优化的能力和实际项目经验
8. 熟练掌握git常用命令并能够使用git进行协作开发

- 工作经历
按时间顺序列举：
工作时间：2021年4月 - 至今
公司名称：所托瑞安（杭州）汽车智能设备有限公司
职位：高级前端工程师

主要职责：
- 负责公司核心产品的前端技术选型与系统架构设计
- 负责公司核心产品功能研发迭代，优化前端性能，提高页面加载速度和用户体验
- 研发基于公司业务发展需要的通用框架、业务组件等，并提供给团队使用, 提高产品研发迭代速度
- 根据公司业务发展，研发帮助前端提效的工具，减少重复工作量，提高开发效率

工作时间：2020年3月 - 2021年4月
公司名称：杭州大搜车汽车服务有限公司
职位：高级前端工程师

主要职责：
- 与产品经理和UI设计师紧密合作，精确实现产品需求与交互，确保产品的技术实现符合设计要求和项目进度。
- 与产品经理和UI设计师紧密合作，精确实现产品需求与交互，根据需求进行页面布局、组件设计和编码实现。
- 编写供各业务线迭代所需业务组件库，遵循编码规范和最佳实践，确保组件代码可维护性和可扩展性。
- 对前端开发过程中出现的问题进行快速定位和解决，提高开发效率。
- 参与项目的测试、部署和维护工作，确保产品质量和稳定性。

工作时间：2017年7月 - 2020年3月
公司名称：杭州宏象信息技术有限公司
职位：前端工程师
主要职责：
- 综合运用前端基本技能与vue2框架主导后台管理系统、h5、企业官网等系统的研发
- 与产品、ui、后端工程师紧密配合，精确还原设计稿与系统功能
- 解决系统在各个浏览器上的兼容性问题

- 项目经验
详细介绍你参与过的项目，包括项目名称、时间、角色和主要职责。着重介绍你在项目中所使用的技术和方法，以及取得的成果。

1. 所托-安行车服平台，pc后台管理系统（公司运营） - 安行车服APP（（服务商、工程师）） - 小程序（车队司机）

- pc后台管理系统核心功能： 
- 负责安行车服务后台管理系统技术选型与架构设计，并主导完成系统单点登录、工单审核、仓储管理物料出入库调拨、客户模块客户定制化服务、服务站信息管理、财务结算等核心模块的持续迭代
- 综合运用react技术栈、灵活使用React的组件通信技巧与React提供的常用Hooks实现各复杂场景的业务功能；
- 通过使用React自定义hook复用公共逻辑的方式将数据列表的查询、展示、与表格分页功能封装为一个通用方法，简化业务开发流程；
- 将常用的弹框表单信息录入功能封装为一个方法，减少每次操作多个相同状态的繁琐过程， 实现快速创建填写弹框表单的能力，提高开发效率。

- 安行车服APP服务商、工程师 
  1. 可操作4种类型订单： 维修、保养、首检、定检
  2. 服务商、工程师 发起工单维修项目：工单状态有： 待分配（分配员工维修）、待估价（填写信息如车辆里程照片 外出费 拖车费 其他费用、申请配件等之后提交审核，由后台系统审核、后台审核通过走到）、待确认、维修中、待报价、待审核、待评价、已完成、审核驳回、维修终止
  3. 客服等派发 保养项目流程添加保养项目：填写保养报价单、申请保养配件、分配员工
  4. 保养预约单，填写想要保养的项目和时间，和个人联系方式。由客服安排派单。
  5. 定检/首检 同样根据首检/定检项目 填写报价单，逐个完成检查项并上传图片填写备注等。
  6. 物料申领、后台审核通过后，填写地址信息，等待发货
  7. 其他功能有： 车辆列表（车辆基础信息和维保信息等）、托管车队管理、账单查看、团队管理。
  - 主导安行车服app H5模块对车辆维修、保养、首检、定检等核心业务线流程的持续迭代。
  - 综合运用vue3技术栈与h5页面开发适配技术
  - 使用jsBridge技术结合对JockeyJS的封装实现与原生android、ios应用的通信
  - 根据研发需求与设计稿，独立设计并封装业务组件库soda-ui,抽象出多场景可复用的业务逻辑与UI设计，供团队快速迭代
  - 运用移动端页面布局技巧并借助autoprefixer、postcss-px-to-viewport插件配置精确还原h5设计稿和交互
  - 使用vue-router实现页面路由、vantUI实现基本UI展现、pinia进行全局数据存储、emit事件通信等实现基本页面功能
  - 综合运用Vue3技术栈vite打包技术、组件通信技巧、实现车辆维修、保养、首检、定检流程的研发，
  - 封装不同类型（BOM物料、常用无聊、全库搜索）物料检索并添加组件、已选物料清单展示组件
  - 


- 安行车服小程序 司机 发起报修
  1. 证件上传进行OCR识别实现车型认证
  2. 一键报修、保养预约地图选点定位、收集语音描述、评价签名、oss图片视频上传和预览
  3. 保养预约
  4. 维修网点申报
  - 独立负责安行车服小程序一键保修、保养预约、维修网点申报、车型认证功能研发
  - 使用uni-app框架结合vue2技术栈，综合运用微信提供的SDK、API实现各类表单信息录入、表单校验、地图选点定位、语音描述、图片、视频等媒体文件OCR识别、上传OSS、canvas实现用户签名等功能

- 工单协同系统
- 使用React+Antd技术栈，综合运用React组件通信技术、hooks逻辑复用、通用组件封装等技术持续跟进车辆管理、车队管理、车队组织架构管理、角色管理与权限配置模块的功能迭代
- 使用React技术栈配合Echarts和react-bmapgl插件独立完成数据看板中安装完工率、安装及时率、维修完工率、维修及时率等统计数据的图表渲染；数据大屏地图打点展示服务站位置与详情等功能
- 独立封装数据列表批量导入导出、数据列表批量操作更改数据状态、操作按钮权限控制等功能
- 独立封装通用的表单信息录入、文件上传下载、详情模块信息展示面板等组件与API
- 角色权限控制
  > 后端接口分别返回菜单列表，和能够操作的按钮列表，根据菜单列表渲染菜单。封装权限按钮，传入props为按钮的唯一标识，根据接口返回的按钮唯一标识做比对，对上了就展示，对不上就不展示。
2. 所托-小安象小程序平台
  - 严选商城、订单列表、
  - 上拉加载分页数据
  - 行驶证驾驶证上传oss并进行ocr识别
  - 接入h5
  - 行驶路线绘制，并回放轨迹、驾驶评分、kpi雷达图、风险指标统计（疲劳驾驶里程、急变道次数、未正确打灯次数、急减速次数、超速次数、分神次数）、风险事件统计（疲劳风险、急变道风险、急减速风险、超速风险、分神风险）
  - 在途互动

  - 数据中心各类统计数据图表展示

  - 使用原生微信小程序技术，综合使用微信提供的SDK与API，持续迭代研发每期需求
  - 独立实现微信一键登录功能，并在各业务场景下判断登录状态，根据登录与否进行相关弹窗交互跳转等
  - 独立负责严选商城各类型商品分页渲染、商品详情展示与下单支付流程，行驶证驾驶证OCR识别、小程序跳转小程序、小程序跳转第三方H5，所托无忧包各类型产品询价与购买流程，在途互动模块语音发送与接收、实时行驶视频观看功能
  - 使用map组件根据经纬度数据实现车辆行驶路线渲染绘制，并回放轨迹
  - 使用charts插件实现驾驶评分、驾驶kpi雷达图、驾驶风险指标统计、驾驶风险事件统计等折线图、条形图的渲染
  - 根据需求封装定制化的tab选项卡组件、轮播图组件、定制化的小程序导航栏组件、定制化提示弹框等
  - 封装上拉加载更多分页数据列表的业务逻辑为一个通用的behaviors，方便多场景列表加载
  - 封装具有点赞、分享、点击暂停/播放、上滑加载下一个视频等功能的视频查看组件
  - 合理运用分包策略、数据渲染策略、静态资源优化策略优化小程序体积和渲染速度


3. 所托- CRM销售管理平台小程序

  - 客户模块、商机模块， 创建、筛选功能、客户详细资料查看与拜访记录记载
  - 各类型数据汇总统计与排行榜展示
  - 使用微信原生小程序开发技术、weVantUI精确还原设计稿
  - 封装可复用的抽屉式筛选组件进行各类型字段的组合筛选

4. 所托-慧管车小程序平台
  - 手机号验证码登录、微信一键登录、微信支付、企业客户余额支付、车架vin码ocr识别并填写基础信息、一键存图
  - 独立完成慧管车小程序平台的架构设计
  - 独立完成微信一键登录、手机号验证码登录功能对接
  - 独立完成个人用户微信支付、企业客户余额支付功能
  - 独立完成行驶证OCR识别车架VIN码校验等表单信息完善
  - 独立完成报告详情页面一键保存图片到本地相册

5. 项目管理平台
- 使用vue3技术栈
- 统一封装新建和编辑缺陷、任务、迭代的功能，使用vue hooks思想提取公共业务逻辑提升开发效率
- 基于Quill库统一封装适用于当前系统的富文本编辑器组件

6. 所托官网
- 使用vue3技术栈，综合运用css3动画属性与HTML技术灵活实现官网中各类滑动显示、渐隐渐显、全屏滚动效果
- 解决不同分辨率适配问题

大搜车

- 弹个车app移动端H5模块金融业务线持续迭代
- 综合运用vue2技术栈实现弹个车金融模块融资租赁业务线各功能模块的研发任务，精确还原设计稿，并实现各类型表单填写、交互与表单校验，图片、视频等资源上传，协议签署等

- 参与搜车金服与链金数据平台管理系统各模块功能研发
- 使用react技术栈实现搜车金服与链金数据平台各模块研发支持

- 使用vue2技术栈 综合运用组件间通信方式、slot插槽等技术实现移动端业务组件库milk-ui研发车辆信息卡片、图片视频上传预览、协议签署、购车方案等

- 使用react+typescript技术栈，灵活使用react组件间通信技术等实现som-ui,完成车型车系多级选择、车辆图片查看器等组件供团队内其他业务线使用，提高迭代速度。


- 宏象信息
云管家后台管理系统
- 使用vue+ElementUI,独立负责中国电信云管家后台管理系统的架构设计与功能研发
- 使用Echarts、根据设计稿与产品交互设定定制化实现曲线图、条形图、饼状图等图表展示，并对大数据量的图表进行任意时间段的截取渲染
- 封装系统面包屑导航组件、菜单栏组件、表单弹框组件、Echarts图表组件等，mixins提取通用逻辑

- 宏象官网
- 

<!-- vue -->
https://juejin.cn/post/7151909645399883807

https://juejin.cn/post/7160445097388179487

https://juejin.cn/column/7139898687873875981 vue3专栏

https://juejin.cn/post/7143358534481575973 【ref、reactive区别】
reactive: 对象数组集合才有响应性作用，解构出来的属性也会失去响应性
ref:适用于任何数据类型


小程序功能汇总：
- 微信授权手机号一键登录
- 手机号验证码登录
- 图片、视频上传与预览
- 新建与编辑收货地址
- wx.scanCode调起客户端扫码界面进行扫码查看技术资料
- wx.chooseMedia 拍摄或从手机相册中选择图片或视频
- 基本表单、级联表单、时间选择、wx.chooseLocation打开地图选择位置、语音发送故障描述、canvas用户手动签名
- 轮播图、滑动导航
- 安全无忧包购买 实名信息、开票信息填写后调接口（传入订单id参数）判断是否已完成e签宝认证，（完成了认证则判断是否已签署合同，已签署合同无需创建合同，未签署，则创建合同，并进入订单详情页查看pdf版本合同详情并进行支付）；没认证则进入第三方的e签宝h5认证页面进行认证，经过一系列认证签署（签署由e签宝平台签署，前端调接口拿结果就行）操作后回到起始页面，在起始页面加载生命周期判断是否已签合同，签过合同的直接到订单详情页面进行订单确认并支付功能
e签宝是一家电子签名服务提供商，其产品包括基础的电子合同服务、身份认证、数字证书、电子签名、时间戳、存证保全和法律支持等服务。
- 风险无忧、修车无忧、轮胎无忧产品询价业务功能迭代
- @lucky-canvas/mini幸运抽奖
- 安币兑换红包到微信钱包
- mp-html渲染富文本内容
- map组件地图绘制、行驶路线绘制、行驶轨迹回放
```html
<map   id="mymap" class="map" longitude="{{mapCenter.longitude}}" latitude="{{mapCenter.latitude}}" scale="{{scale}}" markers="{{markers}}" polyline="{{polylineSettings}}" include-points="polygons" setting="{{mapSettings}}" bindregionchange="updatedMap" max-scale="14">
  <cover-view class="time-map" >{{showMessage}}</cover-view>
</map>
```
- "plugin://echarts/chart" 插件绘制图表
- 合理运用分包策略(独立分包、分包预下载)、数据渲染策略、静态资源优化策略优化小程序体积和渲染速度
- 安全出行模块-安全驾驶激励-前往安全驾驶KPI：根据选择的时间段显示车辆行驶路线，并可以进行行驶轨迹回放。
```html
  <map id="mymap" class="map" longitude="{{mapCenter.longitude}}" latitude="{{mapCenter.latitude}}" scale="{{scale}}" markers="{{markers}}" polyline="{{polylineSettings}}" include-points="polygons" setting="{{mapSettings}}" bindregionchange="updatedMap" max-scale="14">
    <cover-view class="time-map" >{{showMessage}}</cover-view>
  </map>
```
```js
  that.data.trackTimer = setInterval(function () {
    const point = points[index];
    that.data.lastPoint = point;
    //console.log("最后点:",that.data.lastPoint);
    // console.log(point,that.getCurrentTime());
    that.mapCtx.translateMarker({
      markerId:1,
      autoRotate: false,
      moveWithRotate: true,
      duration: duration,
      destination: point,
      rotate: point.gpsBearing,
      fail: function (res) {
        console.log(res);
      },
      success: function () {
        that.setData({
          playIndex: index,
          showMessage: point.addtime,
          'markers[0].latitude': point.latitude || 23.099994,
          'markers[0].longitude': point.longitude || 113.324520,
        })
        that.mapCtx.getRegion({
          success: function (e) {
            if (that.checkOutRegion(point, e.southwest, e.northeast)) {
              that.setData({
                mapCenter: point,
              })
            }
          }
        });
        if (index + 1 >= points.length) {
          that.stopTrack()
        }
        index++;
      }
    })

  }, duration);
```
- 封装统一的图片上传到OSS工具函数
- padding-bottom: env(safe-area-inset-bottom);解决ios底部小黑条问题
- 图片长按弹出菜单
<!-- <image src="{{groupQrcodeUrl}}"	show-menu-by-longpress="{{true}}"></image> -->
- 小程序页面生成图片 wxml-to-canvas和wxml2canvas都有很大限制；建议内置h5并配合使用html2canvas
<!-- https://developers.weixin.qq.com/community/develop/article/doc/00086865f24cd087f16cd13d756013 -->
- 最新油耗分析：查看近期油耗诊断列表，点击每条数据进入详情。（邀请好友）页面链接分享好友或生成海报分享给好友 并邀请好友扫描海报二维码查看个人油耗报告。
- canvas绘制基本海报，并设置保存按钮将canvas绘制的海报保存为图片存到本地
<!-- 
wx.canvasToTempFilePath
把当前画布指定区域的内容导出生成指定大小的图片。在 draw() 回调里调用该方法才能保证图片导出成功。暂不支持离屏 canvas。
 -->

- 扫码查看安全日报
- 加载多个视频的优化
```html
<view class="video-item" wx:for="{{videoList1}}" wx:key="index">
  <van-icon custom-class="custom-play-icon" wx:if="{{_index1 != index}}" bindtap="videoPlay1" data-id="{{index}}" size="48rpx" name="{{playIcon}}" />
  <image src="{{imageCoverList1[index]}}" wx:if="{{_index1 != index}}"   class="video-image"></image>
  <video id="{{index}}" class="video" autoplay="{{true}}" direction="{{0}}" src="{{item}}" wx:if="{{_index1 == index}}" enable-play-gesture="{{true}}" show-fullscreen-btn="{{true}}" show-center-play-btn="{{false}}"></video>
</view>
```



React后台管理系统功能汇总
- https://i.soterea.cn/
- vite、webpack打包工具
- react-router-dom 配置路由
- Antd和AntdProComponents UI组件实现页面登录鉴权和结构布局等界面展示与交互

> react-router是一个通用组件，可以跨平台,内置通用组件和通用Hooks。
> react-router-dom是在react-router基础上提供了Link和NavLink，而且依赖history库提供了两个浏览器端适用的BrowserRouter和HashRouter。一般都用的react-router-dom，一些常用的组件都封装好了。
```js
  import { useNavigate,useParams,useLocation } from 'react-router-dom' 
  const navigate = useNavigate()
  navigate('/order-check-list/detail', {
    state: {
      id: 0
    }
  })
  let location = useLocation();

  // 通过地址栏中的 home?key=value&key=value传递
  const id = location.state ? location.state.id : '1'
  const navigate = useNavigate()
  navigate('/detail?key=value') //跳转方法
  const location = useLocation()
  location.search


  export default function App() {
    let element = useRoutes([
      { path: "/", element: <Home /> },
      {
        path: "user",
        element: <User />,
        children: [
          { path: ":id", element: <User2 /> },
          { path: "user1", element: <User1 /> }
        ]
      },
      { path: "*", element: <NotFound /> }
    ]);
    return <>
        // 这里把上面使用hooks配置的全局路由在这里执行以下
        { element }
    </>
  }
```

- react-pdf 封装pdf查看器组件
- react-to-print封装Table数据列表打印功能
- 结合Antd的Upload组件和API封装统一的Excel数据导入功能
- (js-export-excel)库封装导出Excel的工具函数
- 封装防抖搜索加载远程数据的Select下拉组件
- 实现自定义hooks抽取Table列表的查询、重置、分页展示功能的通用逻辑，提升开发效率
- 通过自定义Schema方式封装通用的搜索栏表单和信息录入表单
- 借助ReactDOM.renderAPI综合运用React组件通信技巧封装实现命令式创建弹框组件，将弹框的显示隐藏、内容展现、确认保存数据等功能收敛在一个方法内，提高迭代速度
- 根据设计稿封装多个图片上传组件
- 根据业务需求结合Antd的Tree组件封装多场景可复用的Tree树形控件
- 封装统一的图标组件，可以加载svg格式、图片格式等（传入阿里巴巴矢量图表库类名或图片的url,如果是url就用img标签，如果是类名用普通的i标签。阿里巴巴矢量图标要下载到本地）。方便多个场景下小图标的引入。
- 使用百度地图插件react-bmapgl库提供的MapvglView、MapvglLayer、Polyline、Label封装个性化展示车辆聚合点和服务站聚合点的Map组件和绘制车辆行驶路线的组件
```js
  import { Map, MapvglView, MapvglLayer } from "react-bmapgl";
  // 车辆的聚合点
  const getCarContainer = useMemo(() => carMapvglView(mapCarData, clickMap),
    [mapCarData.list, mapCarData.show]);

  // 服务站的聚合点
  const getServiceContainer = useMemo(() => serviceMapvglView(mapServiceData, clickMap, detailData),
    [mapServiceData.list, mapServiceData.show, detailData])

  

```


> 防抖（debounce）的原理是，当持续触发事件时，debounce 会合并事件且不会去立刻执行，而是等待一定的时间再执行。如果在这段时间内又触发了事件，则会重新计算延迟时间。

> 而节流（throttle）的原理则是，无论触发事件有多频繁，throttle 都会保证在一定时间内只执行一次事件处理函数。
- 自定义useTableList、useRefs、useDebounce等自定义hooks
```js
import { useState, useEffect } from 'react';

function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

```
```js
import React from 'react';
import useDebounce from './useDebounce';

function SearchInput() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  const handleChange = (e) => {
    setSearchTerm(e.target.value);
  };

  return (
    <input
      type="text"
      value={debouncedSearchTerm}
      onChange={handleChange}
      placeholder="搜索..."
    />
  );
}

```
- 通过时间分片的方式，分次渲染海量数据
> 第一步：计算时间片，首先用 eachRenderNum 代表一次渲染多少个，那么除以总数据就能得到渲染多少次。
> 第二步：开始渲染数据，通过 index>times 判断渲染完成，如果没有渲染完成，那么通过 requestIdleCallback 代替 setTimeout 浏览器空闲执行下一帧渲染。
> 第三步：通过 renderList 把已经渲染的 element 缓存起来，渲染控制章节讲过，这种方式可以直接跳过下一次的渲染。实际每一次渲染的数量仅仅为 demo 中设置的 500 个。
[https://juejin.cn/book/6945998773818490884/section/6959872008326742028](参考代码)
[https://juejin.cn/post/7145488193314357255?searchId=202312041716590B9BE5DF05210147A87B](渲染优化)
小安象管理后台
- 使用React技术栈完成小安运营管理系统中的精选文章管理、热门视频管理、商城管理、订单管理、角色权限管理等模块
> 角色权限控制中，菜单树结构由后端返回。在菜单树中勾选相关的权限，并调接口保存。登录进入系统时调用该角色具有的菜单并渲染

